// backend/src/models/scheduledSessionModel.js

const pool = require('./db');

/**
 * Modelo para gerenciar agendamentos de sessões terapêuticas
 * VERSÃO CORRIGIDA V2 - Agendamento por sessão de trabalho (não por programa específico)
 * Corrige conceito fundamental: 1 sessão pode trabalhar múltiplos programas
 */
const ScheduledSession = {

    /**
     * Cria um novo agendamento de sessão
     * @param {Object} sessionData - Dados do agendamento
     * @param {number} sessionData.assignment_id - ID da atribuição paciente-programa-terapeuta
     * @param {string} sessionData.scheduled_date - Data do agendamento (YYYY-MM-DD)
     * @param {string} sessionData.scheduled_time - Horário do agendamento (HH:MM)
     * @param {number} sessionData.duration_minutes - Duração em minutos (padrão: 60)
     * @param {number} sessionData.created_by - ID do usuário que criou o agendamento
     * @param {string} sessionData.notes - Observações do agendamento
     * @returns {Promise<Object>} O agendamento criado
     */
    async create(sessionData) {
        const {
            assignment_id,
            scheduled_date,
            scheduled_time,
            duration_minutes = 60,
            created_by,
            notes = null,
            therapist_id = null
        } = sessionData;

        // Verificar conflitos antes de criar
        const hasConflict = await this.checkConflict(assignment_id, scheduled_date, scheduled_time, duration_minutes);
        if (hasConflict) {
            throw new Error('Conflito de agendamento: Já existe um agendamento para este terapeuta no mesmo horário.');
        }

        const query = `
            INSERT INTO scheduled_sessions (
                assignment_id,
                scheduled_date,
                scheduled_time,
                duration_minutes,
                created_by,
                notes,
                therapist_id
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            RETURNING *;
        `;

        const values = [assignment_id, scheduled_date, scheduled_time, duration_minutes, created_by, notes, therapist_id];

        try {
            const { rows } = await pool.query(query, values);
            console.log(`[SCHEDULING] Agendamento criado: ID ${rows[0].id}, Assignment ${assignment_id}, Data ${scheduled_date} ${scheduled_time}`);
            return rows[0];
        } catch (error) {
            console.error('[SCHEDULING-ERROR] Erro ao criar agendamento:', error);
            throw error;
        }
    },

    /**
     * Busca agendamentos com filtros opcionais
     * @param {Object} filters - Filtros de busca
     * @param {number} filters.clinic_id - ID da clínica (obrigatório)
     * @param {number} filters.therapist_id - ID do terapeuta (opcional)
     * @param {number} filters.patient_id - ID do paciente (opcional)
     * @param {string} filters.status - Status do agendamento (opcional)
     * @param {string} filters.start_date - Data inicial (opcional)
     * @param {string} filters.end_date - Data final (opcional)
     * @param {number} filters.limit - Limite de resultados (padrão: 100)
     * @param {number} filters.offset - Offset para paginação (padrão: 0)
     * @returns {Promise<Array>} Lista de agendamentos
     */
    async findAll(filters = {}) {
        const {
            clinic_id,
            therapist_id,
            patient_id,
            status,
            start_date,
            end_date,
            limit = 100,
            offset = 0
        } = filters;

        if (!clinic_id) {
            throw new Error('clinic_id é obrigatório');
        }

        let query = `
            SELECT
                ss.*,
                ppa.patient_id,
                ppa.program_id,
                COALESCE(ss.therapist_id, ppa.therapist_id) as therapist_id,
                pat.name as patient_name,
                prog.name as program_name,
                u_therapist.full_name as therapist_name,
                u_creator.full_name as created_by_name,
                ppp.session_date as actual_session_date,
                ppp.score as session_score
            FROM scheduled_sessions ss
            JOIN patient_program_assignments ppa ON ss.assignment_id = ppa.id
            JOIN patients pat ON ppa.patient_id = pat.id
            JOIN programs prog ON ppa.program_id = prog.id
            JOIN users u_therapist ON COALESCE(ss.therapist_id, ppa.therapist_id) = u_therapist.id
            JOIN users u_creator ON ss.created_by = u_creator.id
            LEFT JOIN patient_program_progress ppp ON ss.progress_session_id = ppp.id
            WHERE pat.clinic_id = $1
        `;

        const values = [clinic_id];
        let paramCount = 1;

        // Adicionar filtros opcionais
        if (therapist_id) {
            paramCount++;
            query += ` AND COALESCE(ss.therapist_id, ppa.therapist_id) = $${paramCount}`;
            values.push(therapist_id);
        }

        if (patient_id) {
            paramCount++;
            query += ` AND ppa.patient_id = $${paramCount}`;
            values.push(patient_id);
        }

        if (status) {
            paramCount++;
            query += ` AND ss.status = $${paramCount}`;
            values.push(status);
        }

        if (start_date) {
            paramCount++;
            query += ` AND ss.scheduled_date >= $${paramCount}`;
            values.push(start_date);
        }

        if (end_date) {
            paramCount++;
            query += ` AND ss.scheduled_date <= $${paramCount}`;
            values.push(end_date);
        }

        // Ordenação e paginação
        query += `
            ORDER BY ss.scheduled_date DESC, ss.scheduled_time DESC
            LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
        `;
        values.push(limit, offset);

        try {
            const { rows } = await pool.query(query, values);
            return rows;
        } catch (error) {
            console.error('[SCHEDULING-ERROR] Erro ao buscar agendamentos:', error);
            throw error;
        }
    },

    /**
     * Busca um agendamento específico por ID
     * @param {number} id - ID do agendamento
     * @param {number} clinic_id - ID da clínica (para segurança)
     * @returns {Promise<Object|null>} O agendamento encontrado ou null
     */
    async findById(id, clinic_id) {
        const query = `
            SELECT * FROM v_scheduled_sessions_complete
            WHERE id = $1 AND patient_id IN (
                SELECT id FROM patients WHERE clinic_id = $2
            )
        `;

        try {
            const { rows } = await pool.query(query, [id, clinic_id]);
            return rows[0] || null;
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao buscar agendamento ID ${id}:`, error);
            throw error;
        }
    },

    /**
     * Busca agendamentos de um terapeuta específico
     * @param {number} therapist_id - ID do terapeuta
     * @param {string} start_date - Data inicial (opcional)
     * @param {string} end_date - Data final (opcional)
     * @returns {Promise<Array>} Lista de agendamentos do terapeuta
     */
    async findByTherapist(therapist_id, start_date = null, end_date = null) {
        let query = `
            SELECT * FROM v_scheduled_sessions_complete
            WHERE therapist_id = $1
        `;

        const values = [therapist_id];
        let paramCount = 1;

        if (start_date) {
            paramCount++;
            query += ` AND scheduled_date >= $${paramCount}`;
            values.push(start_date);
        }

        if (end_date) {
            paramCount++;
            query += ` AND scheduled_date <= $${paramCount}`;
            values.push(end_date);
        }

        query += ` ORDER BY scheduled_date ASC, scheduled_time ASC`;

        try {
            const { rows } = await pool.query(query, values);
            return rows;
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao buscar agendamentos do terapeuta ${therapist_id}:`, error);
            throw error;
        }
    },

    /**
     * Atualiza um agendamento existente
     * @param {number} id - ID do agendamento
     * @param {Object} updateData - Dados para atualizar
     * @param {number} clinic_id - ID da clínica (para segurança)
     * @returns {Promise<Object>} O agendamento atualizado
     */
    async update(id, updateData, clinic_id) {
        const allowedFields = ['scheduled_date', 'scheduled_time', 'duration_minutes', 'status', 'notes', 'missed_reason', 'missed_by'];
        const updates = [];
        const values = [];
        let paramCount = 0;

        // Verificar se o agendamento pertence à clínica
        const existing = await this.findById(id, clinic_id);
        if (!existing) {
            throw new Error('Agendamento não encontrado ou não pertence a esta clínica.');
        }

        // Construir query de update dinamicamente
        for (const [key, value] of Object.entries(updateData)) {
            if (allowedFields.includes(key) && value !== undefined) {
                paramCount++;
                updates.push(`${key} = $${paramCount}`);
                values.push(value);
            }
        }

        if (updates.length === 0) {
            throw new Error('Nenhum campo válido para atualizar.');
        }

        // Verificar conflitos se estiver mudando data/hora
        if (updateData.scheduled_date || updateData.scheduled_time || updateData.duration_minutes) {
            const date = updateData.scheduled_date || existing.scheduled_date;
            const time = updateData.scheduled_time || existing.scheduled_time;
            const duration = updateData.duration_minutes || existing.duration_minutes;

            const hasConflict = await this.checkConflict(existing.assignment_id, date, time, duration, id);
            if (hasConflict) {
                throw new Error('Conflito de agendamento: Já existe um agendamento para este terapeuta no novo horário.');
            }
        }

        paramCount++;
        const query = `
            UPDATE scheduled_sessions
            SET ${updates.join(', ')}, updated_at = NOW()
            WHERE id = $${paramCount}
            RETURNING *
        `;
        values.push(id);

        try {
            const { rows } = await pool.query(query, values);
            console.log(`[SCHEDULING] Agendamento atualizado: ID ${id}`);
            return rows[0];
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao atualizar agendamento ID ${id}:`, error);
            throw error;
        }
    },

    /**
     * Remove um agendamento (cancelamento)
     * @param {number} id - ID do agendamento
     * @param {number} clinic_id - ID da clínica (para segurança)
     * @returns {Promise<boolean>} True se removido com sucesso
     */
    async delete(id, clinic_id) {
        // Verificar se o agendamento pertence à clínica
        const existing = await this.findById(id, clinic_id);
        if (!existing) {
            throw new Error('Agendamento não encontrado ou não pertence a esta clínica.');
        }

        const query = 'DELETE FROM scheduled_sessions WHERE id = $1';

        try {
            const result = await pool.query(query, [id]);
            console.log(`[SCHEDULING] Agendamento removido: ID ${id}`);
            return result.rowCount > 0;
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao remover agendamento ID ${id}:`, error);
            throw error;
        }
    },

    /**
     * Marca um agendamento como cancelado
     * @param {number} id - ID do agendamento
     * @param {string} reason - Motivo do cancelamento
     * @param {number} clinic_id - ID da clínica (para segurança)
     * @returns {Promise<Object>} O agendamento cancelado
     */
    async cancel(id, reason, clinic_id) {
        return await this.update(id, {
            status: 'cancelled',
            missed_reason: reason
        }, clinic_id);
    },

    /**
     * Vincula uma sessão realizada a um agendamento
     * @param {number} appointment_id - ID do agendamento
     * @param {number} progress_session_id - ID da sessão realizada
     * @returns {Promise<Object>} O agendamento atualizado
     */
    async linkToCompletedSession(appointment_id, progress_session_id) {
        const query = `
            UPDATE scheduled_sessions
            SET status = 'completed', progress_session_id = $1, updated_at = NOW()
            WHERE id = $2
            RETURNING *
        `;

        try {
            const { rows } = await pool.query(query, [progress_session_id, appointment_id]);
            if (rows.length > 0) {
                console.log(`[SCHEDULING] Agendamento vinculado à sessão: Appointment ${appointment_id} → Session ${progress_session_id}`);
            }
            return rows[0];
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao vincular agendamento ${appointment_id} à sessão ${progress_session_id}:`, error);
            throw error;
        }
    },

    /**
     * Busca agendamentos que podem estar relacionados a uma sessão registrada
     * @param {number} assignment_id - ID da atribuição
     * @param {string} session_date - Data da sessão (YYYY-MM-DD)
     * @param {number} tolerance_hours - Tolerância em horas (padrão: 4)
     * @returns {Promise<Array>} Lista de agendamentos candidatos
     */
    async findCandidatesForSession(assignment_id, session_date, tolerance_hours = 4) {
        const query = `
            SELECT *
            FROM scheduled_sessions
            WHERE assignment_id = $1
              AND scheduled_date = $2
              AND status = 'scheduled'
              AND progress_session_id IS NULL
            ORDER BY ABS(EXTRACT(EPOCH FROM (scheduled_time - CURRENT_TIME))/3600) ASC
            LIMIT 5
        `;

        try {
            const { rows } = await pool.query(query, [assignment_id, session_date]);
            return rows;
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao buscar candidatos para sessão:`, error);
            throw error;
        }
    },

    /**
     * Marca agendamentos vencidos como perdidos
     * @param {number} hours_after - Horas após o agendamento para considerar perdido (padrão: 1)
     * @returns {Promise<Array>} Lista de agendamentos marcados como perdidos
     */
    async markMissedAppointments(hours_after = 1) {
        const query = `
            UPDATE scheduled_sessions
            SET status = 'missed', updated_at = NOW()
            WHERE status = 'scheduled'
              AND scheduled_date < CURRENT_DATE
              OR (
                  scheduled_date = CURRENT_DATE
                  AND scheduled_time < (CURRENT_TIME - INTERVAL '${hours_after} hours')
              )
            RETURNING *
        `;

        try {
            const { rows } = await pool.query(query);
            if (rows.length > 0) {
                console.log(`[SCHEDULING] ${rows.length} agendamentos marcados como perdidos`);
            }
            return rows;
        } catch (error) {
            console.error('[SCHEDULING-ERROR] Erro ao marcar agendamentos perdidos:', error);
            throw error;
        }
    },

    /**
     * Verifica conflitos de agendamento
     * @param {number} assignment_id - ID da atribuição
     * @param {string} scheduled_date - Data do agendamento
     * @param {string} scheduled_time - Horário do agendamento
     * @param {number} duration_minutes - Duração em minutos
     * @param {number} exclude_id - ID do agendamento a excluir da verificação
     * @returns {Promise<boolean>} True se há conflito
     */
    async checkConflict(assignment_id, scheduled_date, scheduled_time, duration_minutes = 60, exclude_id = null) {
        try {
            const { rows } = await pool.query(
                'SELECT check_appointment_conflict($1, $2, $3, $4, $5) as has_conflict',
                [assignment_id, scheduled_date, scheduled_time, duration_minutes, exclude_id]
            );
            return rows[0].has_conflict;
        } catch (error) {
            console.error('[SCHEDULING-ERROR] Erro ao verificar conflito:', error);
            throw error;
        }
    },

    /**
     * Obtém estatísticas de agendamento para um terapeuta
     * @param {number} therapist_id - ID do terapeuta
     * @param {string} start_date - Data inicial (opcional)
     * @param {string} end_date - Data final (opcional)
     * @returns {Promise<Object>} Estatísticas do terapeuta
     */
    async getTherapistStats(therapist_id, start_date = null, end_date = null) {
        try {
            const { rows } = await pool.query(
                'SELECT * FROM get_therapist_appointment_stats($1, $2, $3)',
                [therapist_id, start_date, end_date]
            );
            return rows[0] || {
                total_scheduled: 0,
                total_completed: 0,
                total_missed: 0,
                total_cancelled: 0,
                completion_rate: 0,
                attendance_rate: 0
            };
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao buscar estatísticas do terapeuta ${therapist_id}:`, error);
            throw error;
        }
    },

    /**
     * Busca próximos agendamentos de um terapeuta
     * @param {number} therapist_id - ID do terapeuta
     * @param {number} days_ahead - Dias à frente para buscar (padrão: 7)
     * @returns {Promise<Array>} Lista de próximos agendamentos
     */
    async getUpcomingByTherapist(therapist_id, days_ahead = 7) {
        const query = `
            SELECT * FROM v_scheduled_sessions_complete
            WHERE therapist_id = $1
              AND scheduled_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '${days_ahead} days')
              AND status IN ('scheduled')
            ORDER BY scheduled_date ASC, scheduled_time ASC
        `;

        try {
            const { rows } = await pool.query(query, [therapist_id]);
            return rows;
        } catch (error) {
            console.error(`[SCHEDULING-ERROR] Erro ao buscar próximos agendamentos do terapeuta ${therapist_id}:`, error);
            throw error;
        }
    },

    /**
     * Busca agendamentos que podem ter sessões correspondentes para detecção automática
     * @param {number} lookbackHours - Quantas horas olhar para trás
     * @returns {Promise<Array>} Lista de agendamentos candidatos
     */
    async findPendingDetection(lookbackHours = 24) {
        const query = `
            SELECT
                ss.*,
                ppa.patient_id,
                ppa.therapist_id,
                p.name as patient_name,
                u.full_name as therapist_name,
                prog.name as program_name,
                u.clinic_id
            FROM scheduled_sessions ss
            JOIN patient_program_assignments ppa ON ss.assignment_id = ppa.id
            JOIN patients p ON ppa.patient_id = p.id
            JOIN users u ON ppa.therapist_id = u.id
            JOIN programs prog ON ppa.program_id = prog.id
            WHERE
                ss.status = 'scheduled'
                AND ss.progress_session_id IS NULL
                AND ss.scheduled_date >= CURRENT_DATE - INTERVAL '${lookbackHours} hours'
                AND ss.scheduled_date <= CURRENT_DATE
            ORDER BY ss.scheduled_date, ss.scheduled_time;
        `;

        try {
            const result = await pool.query(query);
            return result.rows;
        } catch (error) {
            console.error('[SCHEDULED-SESSION-MODEL] Erro ao buscar agendamentos para detecção:', error.message);
            throw error;
        }
    },

    /**
     * Detecta e vincula automaticamente uma sessão a um agendamento
     * @param {number} appointmentId - ID do agendamento
     * @returns {Promise<Object>} Resultado da detecção
     */
    async detectAndLinkSession(appointmentId) {
        try {
            // Buscar dados do agendamento
            const appointmentQuery = `
                SELECT
                    ss.*,
                    ppa.patient_id,
                    ppa.therapist_id,
                    ppa.program_id
                FROM scheduled_sessions ss
                JOIN patient_program_assignments ppa ON ss.assignment_id = ppa.id
                WHERE ss.id = $1;
            `;

            const appointmentResult = await pool.query(appointmentQuery, [appointmentId]);
            if (appointmentResult.rows.length === 0) {
                return { success: false, reason: 'Agendamento não encontrado' };
            }

            const appointment = appointmentResult.rows[0];

            // Buscar sessões realizadas no mesmo dia pelo mesmo terapeuta para o mesmo paciente/programa
            const sessionQuery = `
                SELECT
                    ppp.id,
                    ppp.session_date,
                    ppp.created_at,
                    ABS(EXTRACT(EPOCH FROM (ppp.created_at::time - $4::time)) / 60) as time_diff_minutes
                FROM patient_program_progress ppp
                JOIN patient_program_assignments ppa ON ppp.assignment_id = ppa.id
                WHERE
                    ppa.patient_id = $1
                    AND ppa.therapist_id = $2
                    AND ppa.program_id = $3
                    AND ppp.session_date = $5
                    AND ppp.id NOT IN (
                        SELECT DISTINCT progress_session_id
                        FROM scheduled_sessions
                        WHERE progress_session_id IS NOT NULL
                    )
                ORDER BY time_diff_minutes ASC
                LIMIT 5;
            `;

            const sessionResult = await pool.query(sessionQuery, [
                appointment.patient_id,
                appointment.therapist_id,
                appointment.program_id,
                appointment.scheduled_time,
                appointment.scheduled_date
            ]);

            if (sessionResult.rows.length === 0) {
                return { success: false, reason: 'Nenhuma sessão encontrada no mesmo dia' };
            }

            // Pegar a sessão mais próxima em horário (menor diferença)
            const bestMatch = sessionResult.rows[0];

            // Verificar se a diferença de tempo é aceitável (até 2 horas de diferença)
            if (bestMatch.time_diff_minutes > 120) {
                return {
                    success: false,
                    reason: `Sessão encontrada mas com muita diferença de horário (${bestMatch.time_diff_minutes} minutos)`
                };
            }

            // Vincular a sessão ao agendamento
            const linkResult = await this.linkToCompletedSession(appointmentId, bestMatch.id);

            if (linkResult) {
                return {
                    success: true,
                    session_id: bestMatch.id,
                    time_difference_minutes: bestMatch.time_diff_minutes
                };
            } else {
                return { success: false, reason: 'Erro ao vincular sessão' };
            }

        } catch (error) {
            console.error(`[SCHEDULED-SESSION-MODEL] Erro na detecção automática para agendamento ${appointmentId}:`, error.message);
            return { success: false, reason: `Erro interno: ${error.message}` };
        }
    },

    /**
     * Busca administradores de uma clínica
     * @param {number} clinicId - ID da clínica
     * @returns {Promise<Array>} Lista de administradores
     */
    async getClinicAdmins(clinicId) {
        const query = `
            SELECT
                id as user_id,
                name,
                email
            FROM users
            WHERE
                clinic_id = $1
                AND is_admin = true
                AND active = true;
        `;

        try {
            const result = await pool.query(query, [clinicId]);
            return result.rows;
        } catch (error) {
            console.error('[SCHEDULED-SESSION-MODEL] Erro ao buscar admins da clínica:', error.message);
            throw error;
        }
    },

    /**
     * Busca estatísticas detalhadas do sistema de agendamento
     * @param {Object} filters - Filtros opcionais
     * @param {string} filters.start_date - Data inicial
     * @param {string} filters.end_date - Data final
     * @param {number} filters.clinic_id - ID da clínica
     * @returns {Promise<Object>} Estatísticas do sistema
     */
    async getSystemStatistics(filters = {}) {
        const { start_date, end_date, clinic_id } = filters;

        let whereClause = 'WHERE 1=1';
        const params = [];

        if (start_date) {
            params.push(start_date);
            whereClause += ` AND ss.scheduled_date >= $${params.length}`;
        }

        if (end_date) {
            params.push(end_date);
            whereClause += ` AND ss.scheduled_date <= $${params.length}`;
        }

        if (clinic_id) {
            params.push(clinic_id);
            whereClause += ` AND u.clinic_id = $${params.length}`;
        }

        const query = `
            SELECT
                COUNT(*) as total_appointments,
                COUNT(CASE WHEN ss.status = 'scheduled' THEN 1 END) as scheduled_appointments,
                COUNT(CASE WHEN ss.status = 'completed' THEN 1 END) as completed_appointments,
                COUNT(CASE WHEN ss.status = 'missed' THEN 1 END) as missed_appointments,
                COUNT(CASE WHEN ss.status = 'cancelled' THEN 1 END) as cancelled_appointments,
                COUNT(CASE WHEN ss.progress_session_id IS NOT NULL THEN 1 END) as auto_linked_sessions,
                COUNT(CASE WHEN ss.scheduled_date = CURRENT_DATE THEN 1 END) as today_appointments,
                ROUND(
                    (COUNT(CASE WHEN ss.status = 'completed' THEN 1 END)::decimal /
                     NULLIF(COUNT(CASE WHEN ss.status != 'cancelled' THEN 1 END), 0)) * 100,
                    2
                ) as attendance_rate,
                ROUND(
                    (COUNT(CASE WHEN ss.status = 'completed' THEN 1 END)::decimal /
                     NULLIF(COUNT(*), 0)) * 100,
                    2
                ) as completion_rate,
                COUNT(DISTINCT ppa.patient_id) as unique_patients,
                COUNT(DISTINCT ppa.therapist_id) as unique_therapists
            FROM scheduled_sessions ss
            JOIN patient_program_assignments ppa ON ss.assignment_id = ppa.id
            JOIN users u ON ppa.therapist_id = u.id
            ${whereClause};
        `;

        try {
            const result = await pool.query(query, params);
            return result.rows[0];
        } catch (error) {
            console.error('[SCHEDULED-SESSION-MODEL] Erro ao buscar estatísticas do sistema:', error.message);
            throw error;
        }
    },

    /**
     * Busca agendamentos que precisam de notificação de lembrete
     * @param {number} hoursAhead - Quantas horas antes notificar (padrão: 24)
     * @returns {Promise<Array>} Lista de agendamentos para notificar
     */
    async findUpcomingForReminders(hoursAhead = 24) {
        const query = `
            SELECT
                ss.*,
                ppa.patient_id,
                ppa.therapist_id,
                p.name as patient_name,
                u.full_name as therapist_name,
                u.email as therapist_email,
                prog.name as program_name,
                u.clinic_id
            FROM scheduled_sessions ss
            JOIN patient_program_assignments ppa ON ss.assignment_id = ppa.id
            JOIN patients p ON ppa.patient_id = p.id
            JOIN users u ON ppa.therapist_id = u.id
            JOIN programs prog ON ppa.program_id = prog.id
            WHERE
                ss.status = 'scheduled'
                AND ss.scheduled_date = CURRENT_DATE + INTERVAL '1 day'
                AND ss.reminder_sent = false
            ORDER BY ss.scheduled_time;
        `;

        try {
            const result = await pool.query(query);
            return result.rows;
        } catch (error) {
            console.error('[SCHEDULED-SESSION-MODEL] Erro ao buscar agendamentos para lembrete:', error.message);
            throw error;
        }
    },

    /**
     * Marca lembrete como enviado
     * @param {number} appointmentId - ID do agendamento
     * @returns {Promise<boolean>} Sucesso da operação
     */
    async markReminderSent(appointmentId) {
        const query = `
            UPDATE scheduled_sessions
            SET
                reminder_sent = true,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = $1;
        `;

        try {
            const result = await pool.query(query, [appointmentId]);
            return result.rowCount > 0;
        } catch (error) {
            console.error('[SCHEDULED-SESSION-MODEL] Erro ao marcar lembrete como enviado:', error.message);
            throw error;
        }
    }
};

module.exports = ScheduledSession;